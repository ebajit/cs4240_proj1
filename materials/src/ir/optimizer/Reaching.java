package ir.optimizer;

import ir.optimizer.CFG;
import ir.BasicBlock;
import ir.IRInstruction;
import ir.operand.IRVariableOperand;
import ir.BasicBlock;
import ir.IRInstruction;
import ir.operand.IRVariableOperand;

import java.util.HashMap;
import java.util.Map;
import java.util.HashSet;
import java.util.Set;
import java.util.LinkedList;
import java.util.Queue;

public class Reaching {
    private Map<IRInstruction, Set<IRInstruction>> defUseMap;

    /**
     * Constructs a reaching definitions analyzer for the given control flow graph.
     * Performs dataflow analysis to compute which definitions reach each instruction.
     * 
     * @param cfg the control flow graph to analyze
     */
    public Reaching(CFG cfg) {
        this.defUseMap = performDataflowAnalysis(cfg);
    }

    /**
     * Executes the complete reaching definitions dataflow analysis algorithm.
     * Uses the standard iterative approach with gen/kill sets and in/out computation.
     * 
     * @param cfg the control flow graph to analyze
     * @return mapping from each instruction to the set of definitions that reach it
     */
    private static Map<IRInstruction, Set<IRInstruction>> performDataflowAnalysis(CFG cfg) {
        Map<IRInstruction, Set<IRInstruction>> instrDefMap = new HashMap<>();
        Map<BasicBlock, Set<IRInstruction>> blockInSets = new HashMap<>();
        Map<BasicBlock, Set<IRInstruction>> blockOutSets = new HashMap<>();
        Map<BasicBlock, Set<IRInstruction>> blockGenSets = new HashMap<>();
        Map<BasicBlock, Set<IRInstruction>> blockKillSets = new HashMap<>();
        buildGenKillSets(cfg, blockGenSets, blockKillSets);
        runFPIter(cfg, blockInSets, blockOutSets, blockGenSets, blockKillSets);
        createInstrMap(cfg, blockInSets, instrDefMap);
        return instrDefMap;
    }

    /**
     * Constructs generation and kill sets for each basic block in the CFG.
     * Gen sets contain definitions generated by the block, kill sets contain
     * definitions from other blocks that are overwritten by this block.
     * 
     * @param cfg the control flow graph
     * @param genSets output parameter for generation sets
     * @param killSets output parameter for kill sets
     */
    private static void buildGenKillSets(CFG cfg, Map<BasicBlock, Set<IRInstruction>> genSets, Map<BasicBlock, Set<IRInstruction>> killSets) {
        Map<String, Set<IRInstruction>> variableToDefsMap = new HashMap<>();
        for (BasicBlock currBlock : cfg.getBlocks()) {
            for (IRInstruction currInstr : currBlock.getInstructions()) {
                if (currInstr.checkIfDef()) {
                    IRVariableOperand definedVar = currInstr.getAssignedVariable();
                    if (definedVar != null) {
                        variableToDefsMap.computeIfAbsent(definedVar.getName(), k -> new HashSet<>()).add(currInstr);
                    }
                }
            }
        }
        for (BasicBlock currBlock : cfg.getBlocks()) {
            Map<String, IRInstruction> finalDefPerVariable = new HashMap<>();
            Set<IRInstruction> generatedDefs = new HashSet<>();
            Set<IRInstruction> killedDefs = new HashSet<>();
            for (IRInstruction currInstr : currBlock.getInstructions()) {
                if (currInstr.checkIfDef()) {
                    IRVariableOperand definedVar = currInstr.getAssignedVariable();
                    if (definedVar != null) {
                        finalDefPerVariable.put(definedVar.getName(), currInstr);
                    }
                }
            }   
            generatedDefs.addAll(finalDefPerVariable.values());
            genSets.put(currBlock, generatedDefs);
            for (String variableName : finalDefPerVariable.keySet()) {
                Set<IRInstruction> allDefsForVar = variableToDefsMap.get(variableName);
                killedDefs.addAll(allDefsForVar); 
                killedDefs.remove(finalDefPerVariable.get(variableName));
            }
            killSets.put(currBlock, killedDefs);
        }
    }

    /**
     * Performs the iterative fixed-point computation to calculate in and out sets
     * for each basic block using the standard dataflow equations.
     * 
     * @param cfg the control flow graph
     * @param inSet output parameter for block input sets
     * @param outSet output parameter for block output sets
     * @param genSets the generation sets for each block
     * @param killSets the kill sets for each block
     */
    private static void runFPIter(CFG cfg, Map<BasicBlock, Set<IRInstruction>> inSet, Map<BasicBlock, Set<IRInstruction>> outSet, 
                                           Map<BasicBlock, Set<IRInstruction>> genSets, Map<BasicBlock, Set<IRInstruction>> killSets) {
        for (BasicBlock currBlock : cfg.getBlocks()) {
            inSet.put(currBlock, new HashSet<>());
            outSet.put(currBlock, new HashSet<>(genSets.get(currBlock)));
        }
        Queue<BasicBlock> worklist = new LinkedList<>(cfg.getBlocks());
        Set<BasicBlock> worklistContents = new HashSet<>(cfg.getBlocks()); 
        while (!worklist.isEmpty()) {
            BasicBlock currBlock = worklist.poll();
            worklistContents.remove(currBlock);
            Set<IRInstruction> updatedIn = new HashSet<>();
            for (BasicBlock predBlock : currBlock.getPredecessors()) {
                updatedIn.addAll(outSet.get(predBlock));
            }
            Set<IRInstruction> updatedOut = new HashSet<>(updatedIn);
            updatedOut.removeAll(killSets.get(currBlock));
            updatedOut.addAll(genSets.get(currBlock));
            if (!inSet.get(currBlock).equals(updatedIn) || !outSet.get(currBlock).equals(updatedOut)) {
                inSet.put(currBlock, updatedIn);
                outSet.put(currBlock, updatedOut);
                for (BasicBlock succBlock : currBlock.getSuccessors()) {
                    if (!worklistContents.contains(succBlock)) {
                        worklist.add(succBlock);
                        worklistContents.add(succBlock);
                    }
                }
            }
        }
    }

    /**
     * Maps each individual instruction to the set of definitions that reach it
     * by processing instructions within each block and maintaining local state.
     * 
     * @param cfg the control flow graph
     * @param inSet the computed input sets for each block
     * @param instrDefMap output parameter for the instruction-to-definitions mapping
     */
    private static void createInstrMap(CFG cfg, Map<BasicBlock, Set<IRInstruction>> inSet, 
                                               Map<IRInstruction, Set<IRInstruction>> instrDefMap) {
        for (BasicBlock currBlock : cfg.getBlocks()) {
            Set<IRInstruction> localDefSet = new HashSet<>(inSet.get(currBlock));
            for (IRInstruction currInstr : currBlock.getInstructions()) {
                if (currInstr.checkIfDef()) {
                    IRVariableOperand definedVar = currInstr.getAssignedVariable();
                    if (!hasCircularRef(currInstr)) {
                        localDefSet.removeIf(def -> def.checkIfDef() && definedVar.getName().equals(def.getAssignedVariable().getName()));
                    }
                }
                instrDefMap.put(currInstr, new HashSet<>(localDefSet));
                if (currInstr.checkIfDef()) {
                    localDefSet.add(currInstr);
                }
            }
        }
    }

    /**
     * Determines if an instruction uses the same variable it defines in its operands.
     * This handles cases where a variable appears on both sides of an assignment.
     * 
     * @param instr the instruction to check
     * @return true if the instruction uses the variable it defines
     */
    private static boolean hasCircularRef(IRInstruction instr) {
        for (int operandIdx = 1; operandIdx < instr.operands.length; operandIdx++) {
            if (instr.operands[operandIdx] instanceof IRVariableOperand && 
                instr.getAssignedVariable().getName().equals(((IRVariableOperand) instr.operands[operandIdx]).getName())) {
                return true;
            }
        }
        return false;
    }

    /**
     * Returns the computed mapping from instructions to their reaching definitions.
     * 
     * @return map where each instruction is associated with definitions that reach it
     */
    public Map<IRInstruction, Set<IRInstruction>> getReachingDefs() {
        return defUseMap;
    }
}
